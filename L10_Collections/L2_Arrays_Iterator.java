package L10_Collections;

import java.util.Arrays;
import java.util.List;

public class L2_Arrays_Iterator {
    public static void main(String[] args) {

        // =============================================== Класс Arrays ============================================= \\

        // Класс Arrays содержит различные статические методы для работы с Массивами (например, сортировка и поиск)

        // Сортировка массива Arrays.sort()
        int[] numbers2 = {3, 2, 5, 1, 4};
        int[] numbers = {3, 2, 5, 1, 4};
        Arrays.sort(numbers); // [1, 2, 3, 4, 5]
        Arrays.sort(numbers, 0, 4); // [1, 2, 3, 5, 4]
        // Привести содержимое массива к строке Arrays.toString() или Arrays.deepToString() (для многомерного массива)
        String str = Arrays.toString(numbers);
        // Сравнить два массива между собой Arrays.equals()
        Arrays.equals(numbers, numbers2);
        // Заполнить массив одинаковыми значениями Arrays.fill()
        Arrays.fill(numbers, 3, 5, 777);    // заполнить ячейки с 3 по 5 индекс
        // Перевести Массив в List Arrays.asList()
        List<Integer> listNumbers = Arrays.asList(1, 2, 3);
        // Копирование массива Arrays.copyOf(), Arrays.copyOfRange()
        int[] numbersCopy = Arrays.copyOfRange(numbers, 2, 7);  // индекс 7 НЕ входит
        // Бинарный поиск Arrays.binarySearch(). Для этого массив предварительного нужно отсортировать Arrays.sort()
        int[] numbers1 = {3, 2, 5, 1, 4};
        Arrays.sort(numbers1);                 // [1, 2, 3, 4, 5]
        Arrays.binarySearch(numbers1, 4); // вернет индекс ячейки 3
        Arrays.binarySearch(numbers1, 6); // вернет точку вставки -5 - 1 = -6

        // =========================================== Интерфейс Iterable =========================================== \\

        // Интерфейс Iterable – корневой интерфейс для всех классов коллекций Collection.
        // Метод этого интерфейса iterator() возвращает Итератор – объект,
        // абстрагирующий за единым интерфейсом доступ к элементам коллекции.
        //
        // Интерфейс Iterator – это поведенческий шаблон проектирования. Дает возможность последовательно обходить
        // элементы коллекций при сокрытии внутренней структуры данных от пользователя.
        // Это свойство позволяет работать с любой структурой данных как с простой последовательностью или списком.
        // Методы:
        // - forEachRemaining(Consumer<? super E> action) - выполняет данное действие для каждого оставшегося элемента
        // - boolean hasNext() - Возвращает true, если итерация содержит следующий элемент. Не передвигает указатель.
        // - E next() - Передвигает указатель на следующий элемент и возвращает его.
        // - void remove() - Удаляет из коллекции последний элемент, возвращенный методом next(). Получи, чтобы удалить

        // ========================================= Интерфейс ListIterator ========================================= \\

        // Расширяет Iterator, позволяет обойти только List в обоих направлениях и изменить элементы списка.
        // Доступен только для коллекций, реализующих List – получаем его с помощью метода List listIterator()
        //
        // Работа с этим итераторами может пригодиться только в одном случае – удаление элементов
        // (т.к. Iterator не поддерживает add() и remove()). В остальных случаях используем цикл for-each.
        //
        // Методы:
        // void add(E e) - Вставляет указанный элемент в список перед элементом, возвращаемым следующим вызовом next()
        // boolean hasNext() - Возвращает true, если есть следующий элемент.
        // boolean hasPrevious() - Возвращает true, если есть предыдущий элемент.
        // E next() - Возвращает следующий элемент в списке и перемещает положение курсора.
        // int nextIndex() - Возвращает индекс следующего элемента.
        // E previous() - Возвращает предыдущий элемент в списке и перемещает положение курсора назад.
        // int previousIndex() - Возвращает индекс предыдущего элемента.
        // void remove() - Удаляет из списка последний элемент, который был возвращен next() или previous()
        // void set(E e) - Заменяет последний элемент, возвращаемый методом next() или previous(), указанным элементом.

        // ========================================= Enumeration vs. Iterator ======================================= \\

        // Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:
        // - с помощью Enumeration нельзя добавлять/удалять элементы;
        // - в Iterator исправлены имена методов для повышения читаемости кода + он fail-fast
        //   Enumeration.hasMoreElements() соответствует Iterator.hasNext(),
        //   Enumeration.nextElement() соответствует Iterator.next() и т.д;
        // - Enumeration присутствуют в устаревших классах, таких как Vector/Stack,
        //   тогда как Iterator есть во всех современных классах-коллекциях.

        // Как между собой связаны Iterable, Iterator и «for-each»?
        // - Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator

        // ==================================== Fail-fast и Fail-safe итераторы ===================================== \\

        // Это характеристики разных реализаций интерфейса Iterator
        // Они определяют, как поведет себя итератор при изменении перебираемой последовательности элементов.
        //
        // Fail-fast – быстрый итератор. Это итераторы коллекций пакета java.util
        // Если после его создания коллекция изменилась (добавление или удаление не методами итератора) –
        // он бросит исключение ConcurrentModificationException
        //
        // Коллекции поддерживают внутренний счетчик под названием modCount.
        // Каждый раз, когда элемент добавляется или удаляется из коллекции, этот счетчик увеличивается.
        // При итерации при каждом вызове next() текущее значение modCount сравнивается с начальным значением.
        //
        // Если во время итерации по коллекции элемент удаляется с помощью метода итератора remove()
        // это полностью безопасно и не вызывает исключения.
        //
        // Fail-safe – умный итератор. Это итераторы коллекций пакета java.util.concurrent
        // Итератор работает с копией данных – он не бросит исключение при изменении коллекции,
        // но и не увидит обновленных данных. Например, итератор коллекции CopyOnWriteArrayList
        //
        // Другим недостатком являются накладные расходы на создание копии коллекции,
        // как в отношении времени, так и в отношении памяти.
    }
}
