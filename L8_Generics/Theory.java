package L8_Generics;

import java.util.ArrayList;
import java.util.List;

public class Theory {

    // ================================================== Дженерики ================================================= \\

    // Дженерики (Generics) - механизм, который позволяет указывать типы классов и интерфейсов с помощью параметров.
    // Это дает возможность создавать классы, интерфейсы и методы, где тип данных,
    // с которыми они работают, указывается в момент создания объекта или вызова метода (только ссылочный тип)

    // =========================================== Что такое T, E, ? ============================================ \\

    // - T обычно используется для обозначения "типа" элемента. Это обобщенный тип, который позволяет коллекциям
    // быть типизированными, т.е. работать с элементами определенного типа данных.
    // Например, в List<T> T обозначает тип элементов, которые будет содержать список.
    //
    //- E используется для обозначения "элемента" в коллекциях. Это также обобщенный тип, который указывает на тип
    // элементов, хранящихся в коллекции. Например, в ArrayList<E> E обозначает тип элементов в списке. В контексте
    // коллекций E и T часто используются взаимозаменяемо, но E более специфично указывает на элементы коллекции.
    //
    //- ? используется, когда конкретный тип элементов неизвестен. Символ вопроса представляет неизвестный тип.
    // В Java есть два типа wildcard: ограниченный и неограниченный.
    // Неограниченный wildcard обозначается как <?> и говорит о том, что можно использовать любой тип.
    // Ограниченные wildcards разделяются на:
    // верхнюю границу <? extends T> (означает, что можно использовать тип T или любой его подтип) и
    // нижнюю границу <? super T> (означает, что можно использовать тип T или любой его супертип).

    // ============================== Инвариантность, Ковариантность и Контрвариантность ============================ \\

    // PECS (Producer Extends, Consumer Super)
    // Принцип PECS помогает определить, какой wildcard использовать. Если вы производите (читаете)
    // элементы из коллекции, используйте extends; если потребляете (писать) в коллекцию, используйте super.
    public <T> void copy(List<? extends T> src, List<? super T> dest) {
        for (T item : src) {
            dest.add(item);
        }
    }

    // +------------------+--------------------------------+----------------------+------------------------+
    // |       Тип        | Что можно присвоить (=)        | Что можно читать     | Что можно добавлять    |
    // |                  |                                | get()                | add()                  |
    // +------------------+--------------------------------+----------------------+------------------------+
    // | Инвариантный     | только List<Type>              | Type                 | Type                   |
    // | List<Type>       |                                | и предки Type        | и наследники Type      |
    // +------------------+--------------------------------+----------------------+------------------------+
    // | Ковариантный     | List<Type>                     | Type                 | Ничего (null)          |
    // | List<? extends   | и List наследников Type        | и предки Type        |                        |
    // | Type>            |                                |                      |                        |
    // + ------------------+--------------------------------+----------------------+------------------------+
    // | Контравариантный | List<Type>                     | Object               | Type                   |
    // | List<? super     | и List предков Type            |                      | и наследники Type      |
    // | Type>            |                                |                      |                        |
    // +------------------+--------------------------------+----------------------+------------------------+

    // Инвариантность означает, что типы должны быть точно такими же, как и указано; они не могут быть ни их супертипами,
    // ни подтипами. В контексте дженериков это означает, что List<String> не является подтипом List<Object>.
    List<String> strings = new ArrayList<String>();
    // List<Object> objects = strings; // Ошибка компиляции

    // Ковариантность позволяет использовать тип, являющийся подтипом указанного, верхняя граница.
    // Ее можно реализовать с помощью wildcard ? extends T.
    // "Если получаем"
    List<? extends Number> numbers = new ArrayList<Integer>();

    // Контрвариантность - это возможность использовать тип, являющийся супертипом для указанного, нижняя граница.
    // Она достигается с помощью ? super T.
    // "Если отдаем"
    List<? super Integer> integers = new ArrayList<Number>();

    // ================================================== Raw Types ================================================= \\

    // Использование raw types (сырых типов) – это работа с дженериками без указания конкретных типов.
    // Это считается плохой практикой, так как отсутствует проверка типов во время компиляции.
    public void myMethod() {
        List rawListBad = new ArrayList();
        rawListBad.add("string"); // Опасно, нет проверки типов
        // Нужно так:
        List<String> rawListGood = new ArrayList<>();
        rawListGood.add("string"); // Теперь безопасно, есть проверка типов
    }

    // ================================================== Wildcards ================================================= \\

    // Wildcards представлен символом ? и используется для обозначения неизвестного типа, который может быть чем угодно.
    // Wildcards полезны, когда мы работаем с кодом, где конкретные типы не важны или неизвестны.
    public void printList(List<?> list) {
        for (Object elem : list) {
            System.out.println(elem);
        }
    }

    // Множественные ограничения
    // Можно указать несколько ограничений для типовых параметров, используя &
    public class MyClass<T extends Number & Comparable<T>> {
        // T должен быть подтипом Number и реализовывать интерфейс Comparable
    }

    // =============================================== Wildcards типы =============================================== \\

    // 1. Upper Bounded Wildcards (С ВЕРХНЕЙ ГРАНИЦЕЙ) <? extends A>
    // Эти Wildcards нужно использовать, когда вы хотите ограничить неопределенность на переменную.
    // Например, хотим написать метод, который работает на List <Integer>, List <Double>, и List <Number>
    // Можем реализовать, используя Wildcards с верхней границей.
    // Используем Wildcards ("?"), за которым следует ключевое слово extends, за которым следует его верхняя граница.
    //     public static void add(List<? extends Number> list)

    // 2. Lower Bounded Wildcards (С НИЖНЕЙ ГРАНИЦЕЙ) <? super A>.
    // Он выражается с помощью Wildcards ("?"), за которым следует ключевое слово super,
    // за которым следует его нижняя граница:
    //     List<? super Integer> list

    // 3. Unbounded Wildcard (НЕОГРАНИЧЕННЫЙ)
    // Этот тип Wildcards указывается с помощью подстановочного знака (?), например, List<?>.
    // Это называется списком неизвестных типов. Они полезны в следующих случаях:
    // - При написании метода, который можно использовать с использованием функций, предоставляемых в классе Object.
    // - Когда код использует методы универсального класса, которые не зависят от параметра типа.
    //     private static void printList(List<?> list)

    // ===================================================== PECS =================================================== \\

    //Коллекции с wildcards и ключевым словом extends — это producers, производители, они лишь предоставляют данные.
    //
    //Коллекции с wildcards и ключевым словом super — это consumers, потребители, они принимают данные, но не отдают их.

    // +----------------------+--------------------------------+--------------------------------------------+
    // | Тип ограничения      | Что можно читать               | Что можно записывать                       |
    // +----------------------+--------------------------------+--------------------------------------------+
    // | <? extends SomeType> | Объекты SomeType и             | Только null                                |
    // |                      | всех его супертипов            |                                            |
    // +----------------------+--------------------------------+--------------------------------------------+
    // | <? super SomeType>   | Объекты типа Object            | Объекты типа SomeType и всех его подтипов  |
    // |                      |                                | и всех его подтипов                        |
    // +----------------------+--------------------------------+--------------------------------------------+

    // =============================================== Стирание типов =============================================== \\

    // Стирание типов (Type Erasure)
    // Используется механизм стирания типов для обеспечения обратной совместимости.
    // Это означает, что информация о дженериках удаляется во время компиляции, и в рантайме остаются только raw types.
    // То есть при компиляции параметризованный тип превращается в Object
    List<String> list = new ArrayList<String>();  // В рантайме останется просто List

    class Box<T> { // обозначение типа - T
        // переменная с типом T
        private T item;

        public void putItem(T item) { // параметр метода типа T
            this.item = item;
        }

        public T getItem() { // возвращает объект типа T
            return item;
        }
    }

    // Превратится в:
    class BoX {

        private Object item;

        public void putItem(Object item) {
            this.item = item;
        }

        public Object getItem() {
            return item;
        }
    }

}
