package L10_Collections;

import java.util.Comparator;

public class L3_ComparatorComparable {
    // =========================================== Сортировка коллекций ========================================= \\

    // Чтобы сортировать объекты в коллекции – нужно прописать правила их сравнения.
    // Для этого в классе, чьи объекты будут сортированы, должен быть интерфейс Comparable или Comparator.
    //
    // Comparable - позволяет классам быть сравнимыми, реализуется в самом классе как стандартный сравнитель
    // Comparator - отдельный класс-сравнитель, содержит только один метод compare(o1, o2), передается как аргумент

    // Три важных свойства сравнивающей функции
    // Если сравнивающая функция не удовлетворяет этим свойствам, алгоритм может выдать непредсказуемый результат.
    //  - Рефлексивность – сравнение элемента с самим собой всегда возвращает 0
    //  - Антисимметричность – сравнение A с B, и B с A должны дать разный знак.
    //  - Транзитивность – если сравнение A с B, и B с C выдает одинаковый знак,
    //    то и сравнение A с C должно выдать такой же знак.

    // =========================================== Comparator vs. Comparable ======================================== \\

    // Comparable - позволяет классам быть сравнимыми, реализуется в самом классе как стандартный сравнитель
    // Comparator - отдельный класс-сравнитель, содержит только один метод compare(o1, o2), передается как аргумент

    // Интерфейс Comparable является хорошим выбором, когда он используется для определения порядка по умолчанию
    // или, другими словами, если это основной способ сравнения объектов.
    // Затем мы должны спросить себя, зачем использовать Comparator, если у нас уже есть Comparable?
    // Есть несколько причин, почему:
    // - Иногда мы не можем изменить исходный код класса, чьи объекты мы хотим отсортировать,
    //   что делает невозможным использование Comparable.
    // - Использование компараторов позволяет нам избежать добавления дополнительного кода в классы нашего домена
    // - Мы можем определить несколько разных стратегий сравнения, что невозможно при использовании Comparable


    // =========================================== Интерфейс Comparable ========================================= \\

    // Позволяет классам быть сравнимыми

    // Интерфейс Comparable накладывает полный порядок на объекты каждого класса, который его реализует.
    // Этот порядок называется естественным порядком класса, а метод compareTo() - естественным метод сравнения.

    // Списки и массивы объектов, реализующих этот интерфейс, могут быть автоматически отсортированы
    // методами Collections.sort() и Arrays.sort().

    // Объекты, реализующие этот интерфейс, могут использоваться в качестве ключей в SortedMap
    // или как элементы в SortedSet без необходимости указания Компаратора.

    // Чтобы задать свой способ сравнения объектов, нужно переопределить метод compareTo(), где реализовать сравнение.

    class Person implements Comparable<Person> {
        private String fullName;
        private Integer uuid;

        @Override
        public int compareTo(Person person) {
            return uuid.compareTo(person.uuid);
        }

        // Метод compareTo(Object o) сравнивает этот объект с указанным объектом.
        // Возвращает отрицательное целое число, ноль или положительное целое число,
        // если этот объект меньше, равен или больше указанного объекта.

        // Рекомендуется, чтобы (x.compareTo(y)==0) был равен (x.equals(y))

        // Можно сравнивать по нескольким полям класса.
        // Например, если fullName совпадают – тогда сравнить по uuid
        public int compareToEx(Person person) {
            int fullNameComparator = fullName.compareTo(person.fullName);
            int uuidComparator = uuid.compareTo(person.uuid);

            return (fullNameComparator != 0 ? fullNameComparator : uuidComparator);
        }
    }


    class ComparatorEx implements Comparator<PersoN> {
        // =========================================== Интерфейс Comparator ========================================= \\

        // Отдельный класс-сравнитель
        @Override
        public int compare(PersoN p1, PersoN p2) {
            return (Integer.compare(p1.age, p2.age));
        }

        // Comparator используется, когда в классе не реализован,
        // либо реализован с неподходящей логикой интерфейс Comparable, отчего нельзя сравнить объекты нужным образом.

        // Можно создать отдельный класс компаратор, реализовав в нем Comparator.
        // Такой класс будет содержать нужную логику сравнения и его можно будет использовать в аргументах методов,
        // которые требуют Компаратор.

        // Cравнение чисел делаем через Integer.compare
        // Или метод Comparator.comparingInt

        // Можно создать несколько Компараторов для класса и использовать нужный.

        // Можно применять сразу несколько компараторов по принципу приоритета thenComparing()

        // Comparator – функциональный интерфейс, его можно задать лямбда выражением.
        // Статический метод Comparator.comparing принимает функцию ключа сортировки и
        // возвращает компаратор для типа, содержащего ключ сортировки.

        // Для сортировки в обратном порядке reversed()
    }


    class PersoN {
        String name;
        int age;
    }

}

