package L10_Collections;

public class L1_Theory {

    // =============================================== Основные понятия ============================================= \\

    // Структура данных – это контейнер, который хранит данные в организованной форме.
    //
    // Массив – это структура данных, состоящая из упорядоченных ячеек, расположенных друг за другом в памяти,
    // которые могут хранить в себе элементы только одного, заранее заданного типа (примитивы, строки, ссылки)
    //
    // Коллекции - набор связанных классов и интерфейсов, реализующих широко
    // используемые структуры данных. Являются производными от массивов
    //
    // +----------------+----------------+--------------------+----------------+--------------------+
    // |                |             Среднее                 |              Худшее                 |
    // +----------------+----------------+--------------------+----------------+--------------------+
    // |                | Индекс | Поиск | Вставка | Удаление | Индекс | Поиск | Вставка | Удаление |
    // +----------------+--------+-------+---------+----------+--------+-------+---------+----------+
    // | ArrayList      | O(1)   | O(n)  | O(n)    | O(n)     | O(1)   | O(n)  | O(n)    | O(n)     |
    // | Vector         | O(1)   | O(n)  | O(n)    | O(n)     | O(1)   | O(n)  | O(n)    | O(n)     |
    // | LinkedList     | O(n)   | O(n)  | O(1)    | O(1)     | O(n)   | O(n)  | O(1)    | O(1)     |
    // | Hashtable      | n/a    | O(1)  | O(1)    | O(1)     | n/a    | O(n)  | O(n)    | O(n)     |
    // | HashMap        | n/a    | O(1)  | O(1)    | O(1)     | n/a    | O(n)  | O(n)    | O(n)     |
    // | LinkedHashMap  | n/a    | O(1)  | O(1)    | O(1)     | n/a    | O(n)  | O(n)    | O(n)     |
    // | TreeMap        | n/a    | log n | log n   | log n    | n/a    | log n | log n   | log n    |
    // | HashSet        | n/a    | O(1)  | O(1)    | O(1)     | n/a    | O(n)  | O(n)    | O(n)     |
    // | LinkedHashSet  | n/a    | O(1)  | O(1)    | O(1)     | n/a    | O(n)  | O(n)    | O(n)     |
    // | TreeSet        | n/a    | log n | log n   | log n    | n/a    | log n | log n   | log n    |
    // +----------------+--------+-------+---------+----------+--------+-------+---------+----------+
    // Сложности коллекций: https://www.bigocheatsheet.com/

    // ================================================== Коллекции ================================================= \\

    // Коллекция – это объект (контейнер), управляющий группой объектов (элементов).
    //
    // Главным ограничением массива является его фиксированная длина.
    // Эту проблему решают Коллекции – набор интерфейсов и классов для работы с группой однотипных объектов
    //
    // В основе любой коллекции лежит использование того или иного интерфейса, определяющего ее базовый функционал:
    // - Примитивные типы нельзя хранить в коллекции
    // - Хранимые объекты называются элементами
    // - Коллекции хранят только ссылки на объекты
    //
    // Два главных интерфейса коллекций – Collection и Map
    // От них наследуют все другие интерфейсы и классы Collection Framework.
    //
    // Интерфейс Collection наследует интерфейс Iterable, который имеет один метод Iterator<T> iterator(),
    // позволяет последовательно обходить элементы.
    //
    // Map не наследует интерфейс Collection, но входит в состав JCF, хранит данные в виде пары ключ – значение.


    // ============================================= Иерархия коллекций ============================================= \\

    // На вершине иерархии в Java Collection Framework располагаются 2 интерфейса:
    // Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу
    // хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно

    // Интерфейс Collection расширяют интерфейсы:

    // List (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой
    // коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:
    // - ArrayList - представляет обычный массив, длина которого автоматически увеличивается при добавлении элементов.
    // - LinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как данные,
    //   так и две ссылки на следующий и предыдущий узел.
    // - Vector — реализация динамического массива объектов, методы которой синхронизированы.
    // - Stack — реализация стека LIFO (last-in-first-out)

    // Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
    // - HashSet - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый
    //   элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении
    // - LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен
    //   порядку добавления элементов.
    // - TreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
    //   либо сохраняет элементы с использованием «natural ordering».

    // Queue (очередь) предназначена для хранения элементов с предопределенным способом вставки и извлечения FIFO:
    // - PriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при помощи
    //   объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
    // - ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими
    //   реализовать конструкцию вида LIFO (last-in-first-out)

    // - Iterable
    //  - Collection
    //    - List
    //      - ArrayList
    //      - LinkedList
    //      - Vector
    //        - Stack
    //    - Queue
    //      - PriorityQueue
    //      - Deque
    //        - ArrayDeque
    //    - Set
    //      - HashSet
    //      - LinkedHashSet
    //      - SortedSet
    //        - TreeSet
    //  - Map
    //    - HashTable
    //    - HashMap
    //    - LinkedHashMap
    //    - WeakHashMap
    //    - SortedMap
    //      - NavigableMap
    //        - TreeMap

    // ============================================= Map не в Collection ============================================ \\

    // Интерфейс Map реализован классами:
    // - Hashtable — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве
    //   значения или ключа и не является упорядоченной
    // - HashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
    // - LinkedHashMap — упорядоченная реализация хэш-таблицы.
    // - TreeMap — реализация основанная на красно-черных деревьях. Является упорядоченной и предоставляет
    //   возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
    //   либо сохраняет элементы с использованием «natural ordering».
    // - WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references для ключей
    //   (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора,
    //   если на ключ этого элемента нет жёстких ссылок).

    // ========================================== Collection vs Collections ========================================= \\

    // В чем разница между классами java.util.Collection и java.util.Collections?
    // java.util.Collections - набор статических методов для работы с коллекциями, утилитарный класс
    // java.util.Collection - базовый интерфейс для всех коллекций, определяет основной функционал

    // ========================================== ArrayList vs. LinkedList ========================================== \\

    // В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости
    // выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или
    // в случаях, когда необходимо гарантированное время добавления элемента в список.

    // ========================================== Comparable vs Comparator ========================================== \\

    // Comparable: позволяет классам быть сравнимыми, метод compareTo(E item)
    // Реализуется внутри класса, определяет единственный порядок сравнения объектов

    // Comparator: отдельный класс-сравнитель, метод compare(). В классе только метод-сравнитель.
    // Реализуется вне класса, можно реализовывать несколько разных сортировок

    // ============================================ ArrayList vs. Vector ============================================ \\

    // - Методы класса Vector синхронизированы, а ArrayList - нет;
    // - По умолчанию, Vector удваивает свой размер, когда заканчивается выделенная под элементы память.
    //   ArrayList же увеличивает свой размер только на половину.
    // - Vector это устаревший класс и его использование не рекомендовано.

    // =============================================== Класс Optional =============================================== \\

    // Опциональное значение Optional — это контейнер для объекта, который может содержать или не содержать
    // значение null. Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет
    // некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/notNull проверок.
}


