package Amain;

// Оглавление (ссылки)


public class Theory {
    public static void main(String[] args) {System.out.println("Оглавление");}

    HOTKEYS hotkeys;
    JAVACORE javacore;
    JAVA java;
    OOP oop;
    GarbageCollector gc;
    Exceptions exceptions;
    Logging logging;
    Serialize serializable;


class HOTKEYS {}

/* * Hotkeys for IDE

Ctrl + D - дублирование всей строки кода;
Ctrl + X - удаление одной строки кода;
Ctrl + ← / → - переход по словам влево / вправо (а не по символам);
Ctrl + Shift + ↓ / ↑ - перемещение строки кода вниз / вверх;
Ctrl + Alt + L  - Форматирование кода;
Ctrl + Delete  - Удалить слово после курсора;
Ctrl + Backspace  Удалить слово перед курсором;
Ctrl + Shift + F10  Выполнить текущую программу (а не искать какаую именно в списке нужно выполнить, когда у тебя список из: test, test(1), test(2), main и т.д.)
Shift + F6 - Переименовать что-то во всем коде (выделяешь переменную или метод, вводишь новое имя и IDEA исправляет ВЕЗДЕ по проекту это название на новое)
Alt + ← / → - переход по классам между вкладками.
Shift + F11 ставим закладку, выбираем обозначение символом, потом из любого места проекта можно перейти прямо на закладку посредством Ctrl + (обозначеный символ) например мы выбрали символ '1', соответсвенно комбинацией Ctrl + 1 мы попадаем на нашу закладку и не надо искать наш файл / класс в дереве или держать постоянно открытым в окне.
Еще я при работе всегда прячу консоль, т.к. она занимает много места внизу. Быстрый вызов: Alt + 4;
Быстрый вызов дерева / каталога файлов проекта: Alt + 1;

 */

}

class JAVACORE {}

/* # JavaCore
//
Java = WORA
JDK = JRE + JAVAC + (library, examples, doc, utility)
JRE = JVM + ClassLoader + Library
JVM - выполняет байт-код, полученный после компиляции
JIT - преобразует байт-код в машинный в горячих точках программы, улучшая производительность

//
Примитивные типы:
    * целочисленные: byte(1), short(2), int(4), long(8).
    * вещественные : float(4), double(8).
    * символьные:  char(2).
    * логический: boolean(1 в массиве, 4).

Ссылочные типы: все остальные
char + short = int, при арифметических операциях автоматически приводятся к int.
&& не вычисляет значение второй части (0 && pass) = 0, & принудительно вычисляет

Явное преобразование: преобразование в другой тип, который может привести к потере данных или точности
Неявное преобразование: автоматически, когда преобразование расширяет размер типа без потери
Потери при неявных приведениях:
    * int -> float
    * long -> float
    * long -> double

Autoboxing - преобразование примитива в соответствующий класс-обертку
Unboxing - преобразование объекта класса-обертки в примитивный тип

//
Массив — это структура данных, позволяющая хранить фиксированное количество элементов одного типа.
         ограничения: размер массива неизменяем после создания, хранит только элементы одного типа.

StringBuffer vs StringBuilder:
    1. Buffer является потокобезопасным, его методы синхронизированы. Для многопоточки. Медленнее
    2. Builder используется в однопотоке, более быстрый

//
break используется для выхода из цикла или switch-конструкции,
      расширенная версия может использоваться с метками для выхода из внешних циклов.
continue пропускает оставшуюся часть тела цикла и переходит к следующей итерации.

//
Стек - тут хранятся примитивы и ссылки на объекты, LIFO. Потокобезопасен, для каждого создается отдельный стек
       При вызове метода создается фрейм (параметр метода, указатель на прошлый фрейм, локальные переменные). После выполнения он удаляется
Куча - тут создаются и хранятся объекты и их поля, динамическое выделение памяти. Автоматически не освобождается
       Состоит из Young, Old, MetaSpace (метаданные классов) generation
Пул (pool) данных, хранятся в куче - набор уникальных данных
    1. String: если создается строка, которая уже существует, то не создастся новый объект, а будет использоваться ссылка на уже существующий
               можно добавить через intern(). Если строки нет в пуле - добавляется. В итоге возвращается ссылка на нее
    2. Integer: создается при объявлении Integer, от -128 до 127. Объекты в этом диапазоне ссылаются на одно значение 100==100: true, 129==129: false
    3. Также для всех примитивов в классах-обертках существует пул (Boolean, Character)

//
Переопределение equals и hashCode:
    equals изначально проверяет равенство ссылок (==), поэтому для корректного сравнения его необходимо переопределить:
        1. Рефлексивность (объект равен самому себе, this == O)
        2. Симмеричность (a = b, то и b = a, равенство классов)
        3. Транзитивность (a = b, a = c, то и b = c)
        4. Постоянство (результаты меняются только при изменении ввода)
        5. Неравенство с null (O != null)
    hashCode - это "прикидка": объекты возможно равны? Если да, вызываем equals для точного сравнения
    Если переопределить только один метод, то нарушится контракт и возможна некорректная работа (HashMap'ы, например)

//
var используется для упрощения синтаксиса объявления переменных,
    позволяя компилятору автоматически определять тип переменной на основе присваиваемого ей значения.

*/

class JAVA {}

/* #Java
//
Класс состоит из:
1. Конструктора - специального метода класса, который вызывается при создании нового объекта этого класса.
    * Можно вызвать один конструктор из другого через this() или из потомка через super()
2. Полей (переменных)
3. Методов (функций)


Класс Object и класс Class: Object - корневой класс, от которого наследуются все остальные классы. Не наследуюься Object и ENUM
                            Class - класс в Java, объекты которого представляют классы и интерфейсы во время выполнения программы.
Все методы Object: equals(), hashCode(), toString(), clone(), getClass(), finalize().


Vargs: позволяют методу принимать ноль или более аргументов.
       ограничения: должен быть последним в списке параметров метода, и может быть только один varargs в методе.

Передача:  В Java примитивные типы передаются по значению,
                  объекты - по ссылке (точнее, копия ссылки передается по значению).
                  Если передать как аргумент, массив изменится, строка - нет

//
Перегрузка vs Переопределение: перегрузка (overloading) позволяет создавать несколько методов с одинаковым именем, но разными параметрами.
                               переопределение (overriding) - это изменение реализации метода унаследованного от родительского класса.

Перегрузка hashCode и equals необходима для корректной работы объектов в коллекциях, особенно в хеш-таблицах.
                             если два объекта равны согласно методу equals(), то их hashCode() должны быть одинаковыми.

Правила хэшкод: Должен возвращать одинаковое значение для одного и того же объекта в течение одного запуска программы, может возвращать одинаковое значение для разных объектов.
Правила equals: Должен быть рефлексивным, симметричным, транзитивным, консистентным и возвращать false для null.


Instanceof vs getClass: instanceOf проверяет, является ли объект экземпляром класса или его подкласса (проверяет всю цепочку наследования),
                        getClass() возвращает точный класс объекта.

//
Модификаторы доступа
    1. public: видимы и доступны везде
    2. protected: видимы и доступны внутри пакета и в наследниках
    3. default: видимы и доступны только внутри пакета
    4. private: члены класса доступны только внутри класса

Static
1. Переменные (поля): принадлежат классу, а не объекту -> одна переменная на все экземпляры
2. Методы: могут быть вызваны без создания объекта класса (Class.method()). Обращаются только к static переменным.
           cтатические методы могут быть вызваны из нестатических, но не наоборот
3. Блоки инициализации: инициализация статических переменных. Выполняются один раз, пишутся перед конструктором
4. Классы (вложенные статические): могу быть использованы без создания экземпляра внешнего класса, имеют доступ только к статическим переменным

Final
    1. Класс: не может иметь наследников
    2. Метод: не может быть переопределен в классах наследниках
    3. Поле: не может изменить значение после инициализации
    4. Параметры методов: не могут изменять свое значение внутри метода
    5. Локальные переменные: не могут быть изменены после присвоения значения

//
Abstract (is a - является), extends
    * используется, когда классы имеют общую реализацию некоторых методов. Может содержать поля и конкретные методы
    * наследуется только один раз, класс "растворяет" собственную индивидуальность
    * есть конструктор

Interface, implements
* используется для определения контракта, который классы должны реализовать. Подходят для определения общего поведения, которое может быть разным для классов
* нет конструктора и состояния, все методы public abstract или default, поля public static final
* множественное наследование без иерархии, класс расширяет функциональность
* может наследоваться от других интерфейсов, нет геттеров и сеттеров

Итерфейс-маркер - пустой интерфейс, не содержащий методов (например, Sizeable, Cloneable, Remote),
                  это значит, класс обладает определенным свойством или характеристикой
                  цель - предоставить способ использования метаданных для объектов во время выполнения программы.

default в интерфейсе позволяет добавлять новые методы с реализацией в интерфейсы.
        Нужен для обратной совместимости (добавляем новые методы в интерфейс, но ничего не изменяем в классе, реализующем интерфейс)
        то есть не обязательно переопределять defaultMethod()

//
Блоки инициализации - это специальные блоки кода, которые выполняются при создании объекта класса.
                      Они помогают инициализировать объекты класса перед использованием
    1. Нестатические БИ:
        * выполняются каждый раз при создании объекта класса, до вызова конструктора
        * используются для инициализации экземпляров класса
    2. Статические БИ:
        * определяются ключевым словом static
        * выполняются один раз при загрузке класса, до создания объекта класса или вызова любого статического метода
        * используюся для инициализации ститических переменных класса
        * если несколько блоков, они выполняются в порядке их объявления

//
Типы классов
    * обычный: определяет объекты
    * астрактный: задает общее поведение
    * интерфейс: базовый класс для других, не может быть инстанциирован (создан экземпляр)
    * финальный: запрещает наследование
    * перечисление (enum): набор констант, не может наследовать
    * вложенный: класс внутри класса
    * статический вложенный: не требует внешний экземпляр
    * простой внутренний: требует внешний экземпляр, имеет доступ даже к private полям родителя
    * локальный: используется в блоке кода или метода
    * анонимный: без имени, только одноразовый, после порождения нельзя ссылаться,
                 обычно используются для немедленного расширения класса или реализации интерфейса,
                 могут представляться как лямбда-выражение (чистого выражения)

Чтобы класс был имуттабельным (неизменяемым), должны соблюдаться следующие условия:
    1. класс final
    2. все поля private final
    3. нет сеттеров (методов для изменения)
    4. возвращать не объекты, а их копии в геттерах
    5. получать копии объектов (в конструкторе или методе)


native указывает, что метод реализован на нативном языке, например, на C или C++.
       такие методы позволяют выполнять операции на низком уровне, которые невозможны или неэффективны в Java.
       Плюсы: производительность и доступ к системным ресурсам. Минусы: уменьшение переносимости и увеличение сложности.

strictfp указывает, что метод (класс) выполняет вычисления с плавающей точкой строго в соответсвии со стандартом IEEE 754.
         это нужно для точности и предсказуемости результата на разных платформах

Проблема ромбовидного (множественного) наследования возникает при наследовании от двух классов (или интерфесов), это приводит к неоднозначности.
         Решение: переопределить конфликрующий метод (@Override) и явно указать, какую реализацию использовать, или создать свою реализацию
         Пример реализации: [interfaceName].super.[methodName]. Или создать свой метод (реализацию)

*/


class OOP {}

/* # ООП и основные принципы
//
ООП - методология программирования, основанная на концепиях классов и объектов, где классы образуют иерархию, а объекты являются экземплярами
Класс - скелет еще не созданного объекта
Объект - экземпляр класса
У объекта есть:
    идентичность - то, что отличает объекты
    состояние - набор всех полей
    поведение - набор всех методов

//
Инкапсуляция - скрытие внутреннего состояния объекта и предоставление публичных методов для доступа к этому состоянию
Наследование - порождение одного класса от другого с сохранением всех свойств и методов класса-родителя,
               добавляя новые свойства и методы. Множественное наследование запрещено
Полиморфизм - возможность использовать объект производного класса, вместо родительского. Переопределение или перегрузка
Абстракция - выделение наиболее важных характеристик объекта, создаем только важные переменные

//

Ассоциация (has a) - наличие связи между объектами, они могут ссылаться друг на друга.
    Агрегация - связь, часть может существовать отдельно от целого (книга и библиотека). Вложенный статический класс
    Композиция - связь, часть существует только с целым (страница и книга). Вложенный класс

Связывание - наличие связи между ссылкой и кодом
Раннее связывание - связывние на этапе компиялции. Дженерики, перегруженные, private, final, static методы. Используется ссылка
Позднее связывание - динамическое, происходит во время выполнения программы. Объекты создаются во время работы. Абстрактные и переопределенные методы
Коллизия - ситуация, когда два разных объекта или значения имеют один и тот же хэш-код.
           решение: использовать цепочку, где каждая ячейка хэш-таблицы содержит не один объект, а список (цепочку) объектов, имеющих одинаковый хэш-код

//
SOLID
1. Принцип единственной ответственности. Каждый класс должен иметь одну инкапсулированную обязанность
2. Принцип открытости/закрытости. Сущности (классы, модули, методы) открыты для расширения, но закрыты для изменения
3. Принцип подстановки Лисков. Возможность поменять базовый класс на производный без изменения поведения программы
4. Принцип разделения интерфейсов. Клиенты не должны зависить от методов, которые они не используют. Несколько интерфейсов лучше одного универсального
5. Принцип инверсии зависимостей. Модули верхних уровней не должны зависеть от модулей нижних, а оба типа должны зависеть от абстракций.
                                  Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций (фигура и круг)

//
ClassLoader - загружает классы в память при их первом использовании (ленивая загрузка), преобразуя их из байт-кода в машинный код
    1) Загрузка. Находит и загружает бинарные данные класса в память
    2) Связывание.
        - Проверка корректности кода
        - Выделение памяти для статических полей, инициализация стандартными значениями
        - Преобразование символических ссылок на другие классы/методы/поля в прямые
    3) Инициализация. Выполнение статических инициализаторов и инициализация статических полей в порядке их объявления

Типы загрузчиков при запуске JVM:
    1) Стандарные классы (bootstrap)
    2) Классы расширений (extensions)
    3) Классы приложения (system)
Каждый загрузчик хранит указатель на родительский, чтобы делигировать ему загрузку, если сам не в состоянии делать. Сначала до верхушки, потом вниз

*/


class GarbageCollector {}

/* # Garbage Collector GC
//
GC используется для автоматического управления памятью.
Кратко: если нельзя дотянуться до объекта из стека - объект удаляется
Два способа определения:
    1. Учет ссылок: если объект не имеет ссылок, он считается мусором (невозможно выявить циклические ссылки)
    2. Трассировка: если до объекта нельязя дотянуться из корневых точек (объекты статических полей/из стека потоков/из JNI), то он считается мусором

//
Виды GC:
    1. Serial
        * работает в однопотоке, останавливает всё приложение для сборки мусора
        + прост в использовании
        - паузы в работе приложения, не подходит для многопоточных приложений и серверов
    2. Parallel
        * использует несколько потоков, работает параллельно с приложением, останавливает всё приложение, ориентир на производительность
        + производителен на многопроцессорных системах
        - приводит к более длительным паузам в сравнении с Serial
    3. Concurrent Mark Sweep (CMS)
        * минимизирует паузы,  работает параллельно с приложением
        + небольшие паузы
        - потребляет больше ресурсов процессора, сложен в настройке
    4. Garbage-First (G1) - самый популярный
        * разделяет кучу на регионы и собирает мусор сначала в тех, где это наиболее эффективно
        + короткие предсказуемые паузы, высокая производительность в больших системах, многопоточен
        + инкриментальная сборка: может ограничивать количество работы в паузе, чтобы удерживать ее в заданном пределе
        - может быть менее эффективен на маленьких объемах данных или в приложениях с меньшими требованиями к паузам
        Этапы:
            1) Minor GC
                - размещаются новые объекты в молодом поколении
                - место заполняется -> удаляются неиспользуемые
                - используемые перемещаются в пространство выживших
                - если выживщие долго используются, то перемещаются с старое поколение
            2) Major GC
                - долго проверяет все объекты в старом поколении, STW
                - живые объекты перемещает в начало (уплотняет), мусор остается в конце
            3) Full GC
                - запускает сначала Minor, затем Major
    5. ZGC
        * использует регионы памяти и колорированные указатели для уменьшения пауз, инкрементальная сборка
        + очень короткие паузы, масштабируется до больших объемов памяти
        - может использовать больше системных ресурсов
    6. Shenandoah
        * работает параллельно с приложением, инкрементальная сборка
        + очень короткие паузы, на зависит от размера кучи
        - может использовать больше системных ресурсов (CPU), сложен в настройке и оптимизации
    7. Epsilon GC - эксперементальный
        * не выполняет сборку мусора
        + приложения работают без пауз, может использоваться для тестирования
        - не предназначен для использования в проде или в приложениях

//
Есть два подхода к сборке мусора:
    1. Stop-the-world - остановка приложения [app-app-app-gc]
        + проще определить достижимость объектов (граф заморожен), проще перемещать объекты в куче
        - приложение останавливается, зависит от объема кучи
    2. Инкриментальная сборка [(gc+app)-(gc+app)-(gc+app)]
        + уменьшает паузы (много коротких пауз, фоновая сборка)
        - требуется синхронизировать работу с приложением, занимает больше времени

Определение производительности GC:
    1. Throughput (пропускная способность) - объем используемых вычислительных ресурсов
    2. Latency (задержка) - на какое время прерывается работа
    3. Footprint (след) - объем используемой памяти
    Оптимизируем 2 из 3 компонентов / изменеяем размер кучи

*/

class Exceptions {}

/* # Исключения

Исключение - объект, который описывает исключительное состояние, возникшее в каком-либо участке программного кода,
             представленны классом Throwable и его подклассами (Error и Exception).
             Error указывает на серьезные ошибки, которые обрабатывать не нужно,
             Exception делится на две категории:

Checked исключения - должны обрабатываться блоком catch, проверяются при компиляции
        * IOException - вввод-вывод, может возникать при работе с файлами (файла не существует)
        * SQLException - исключения, связанные с доступом к базе данных
        * ClassNotFoundException - приложение пытается загрузить класс через его строковое имя
        * InterruptedException - поток в режиме ожидания перекрывается другим потоком (Thread.sleep())
        * NoSuchMethodException - метод не найден
        * MalformedURLException - неправильно сформированный URL
Unchecked исключения - могут не обрабатываться, проверяются при выполнени, возникают из-за ошибок в логике программы
        * наследуются от RuntimeException
        * Ошибки (Error)
        * NullPointerException - используется null вместо объекта (например, при вызове метода у null ссылки)
        * ArrayIndexOutOfBoundsException - обращение по выходящему за пределы индексу массива
        * ClassCastException - попытка приведения типа объекта к другому несовместима
        * ArithmeticException - арифметические ошибки, деление на ноль
        * IllegalArgumentException - недопустимый аргумент
        * NumberFormatException - неудачное преобразование строки в числовой тип

//
Чтобы выбросить исключение используется 'throw ... new Exception()'

Отлавливание исключений:
    1. try - блок, в котором может появится исключение
    2. catch - указываем исключение и его обработку
        * можно отлавливать сразу несколько исключений-братьев (catch E1 | E2 | E3 e) должны быть на одном уровне иерархии
        * обращаемся от наследника к предку
    3. finally - отработает всегда, кроме ситуаций:
        * в try или catch используется System.exit()
        * происходит сбой JVM
        * уничтожается выполняющий поток

//
Throw и throws
Throw - используется для явного выброса исключения
    * может быть использован в любом месте кода
    * после throw следует экземпляр класса (throw new SomeException("Сообщение об ошибке"))
    * одно исключение за раз
Throws - используется в сигнатуре (описании) метода для указания, что метод может выбрасить исключение, это важно для checked исключений
    * не выбрасывает исключение, лишь показывает, что метод может выбросить исключение
    * позволяет обработать исключение в вызывающем коде или передать его дальше по стеку вызовов
    * исключения должны быть обработаны в вызывающем коде (через try)

//
Try with resources позволяет объявить ресурсы в блоке try, которые будут автоматически закрыты без finally (через .close())
try (FileInputStream fis = new FileInputStream("file.txt"); Scanner scanner = new Scanner.System.in()) {}
Закрываются в обратном порядке.

Подавленное исключение - вызывается, но игнорируется, встречается только в методах .close()
При появлении подавленного исключения, первое исключение считается главным, остальные - подавленные.
Любое исключение, первоначально возникшее в try, затем подавляется

//
Создание собственных исключений
1. Необходимо наследоваться от класса Exception (для проверяемых исключений) или от RuntimeException (для непроверяемых исключений)
2. Определить конструкторы, как в любом другом классе

Общие рекомендации:
1. Использовать исключения только для исключительных ситуаций, а не для упарвления потоком выполнения
2. Использовать стандартные исключения
3. Указывать сообщение об ошибке, чтобы сделать причину исключения ясной
4. Не делать пустых блоков catch
5. Использовать try-with-resources (по возможности), чтобы автоматический закрывать ресурсы, реализующие интерфейс AutoCloseable

 */

class Logging {}

/* # Логирование

Логирование - процесс записи информации о работе программы для анализа. Все логи должны быть одинаково форматированы
Java Logging API - часть JavaSE, предоставленная в пакете java.util.logging. Основные компоненты:
    1. Logger - класс, используемый для логгирования, иерархически организован и может наследовать уровни логгирования и обработчиков
    2. Level - уровень логгирования
        * SEVERE - указывает на проблему, которая предотвращает дальнейшее ее выполнение
        * WARNING - предупреждает о возможной проблеме
        * INFO - используется для информирования
        * CONFIG - информация о конфигурации и настройках программы
        * FINE - отладочная информация
        * FINER - более детализированная отладочная информация
        * FINEST - наиболее детализированная отладочная информация

        * OFF - отключение логгирования
        * ALL - логгирование всех сообщений
    3. Handler - место назначения логгируемых сообщений (файл, консоль)
    4. Formatter - определяет формат ввода логгируемых сообщений

//
Чтобы передавать значения в логи, используются плейсхолдеры {}:
       logger.debug("User {} as logged in at {}", username, LocalDateTime.now()); - так в Log4j
 */

class Serialize {}

/*
Сериализация - сохранение объекста в последовательность байт для компактного хранения или передачи,
               реализована через интерфейс-маркер (без методов) Serializable
Десериализация - восстановление объекта из байт

Метод clone() объявлен в классе Object, а не в интерфейсе Cloneable.
      объявлен с сигнатурой native -> доступ к механизму поверхностного копирования
      объявлен как protected -> нельзя вызвать метод у не переопределивших его объектов

//
Этапы:
    1. Запись метаданных
    2. Запись информации (описания классов) от родителя до наследника
    3. Запись примитивов
    4. Запись в поток
Условия:
    1. Класс объекта должен реализовывать интерфейс Serializable
    2. Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream
    3. Записать в поток oos.writeObject(Object)
    4. Сделать oos.flush() и oos.close() - очистить буфер и закрыть

//
Как изменить стандартное поведение сериализации и десериализации?
    Использовать интерфейс Externalizable и переопределить методы
    writeExternal(ObjectOutput out) throws IOException
    readExternal(ObjectInput in) throws IOException, ClassNotFoundException

Разное:                           Поток Ввода (как сканнер)    Поток Вывода (как принтер)
Работает с байтами                InputStream                  OutputStream
Работает с символами (Unicode)    Reader (чтение)              Writer (запись)

//
Потоки и что они обрабатывают:
    1. Байтов - ввод-вывод необработанных двоичных данных
    2. Символов - ввод-вывод символьных данных, преобразуют в локальный набор символов и обратно
    3. Буферизированные - оптимизируют ввод и вывод, сокращая кол-во вызовов собственного API
    4. Сканирование и форматирование - читают и пишут форматированный текст
    5. Ввод-вывод из командной строки - описывают стандартные потоки и объект консоли
    6. Данных - обрабатывают двоичный ввод-вывод примитивов и строк
    7. Объектов - обрабатывают двоичный ввод-вывод объектов

//
Тонкости сериализации:
    НЕ будут сериализированны:
        1. Static поля
        2. Transient поля (после восстановления его значение будет null)
                     например, кэш и другие данные, которые легко вычислить
        3. С аннотацией @Transient
    Поля с модификатором final сериализуются как обычные, но их невозможно десериализовать через Externalizable ->
        использовать конструктор для инициализации final поля

Поле serialVersionUID содержит уникальный идентификатор версии сериализованного класса
     идентификатор есть у любого класса, который использует интерфейс Serializable
     он вычисляется по содержимому класса: полям, порядку объявления, методам.
     Меняем что-то в классе -> меняется идентификатор версии

     Если не объявить поле явно, то даже лишний пробел будет считаться изменением. Поэтому смотрим, являются ли
     изменения обратно-совместимыми. Да - версию не меняем

     Значение serialVersionUID менять стоит только если вы сознательно хотите нарушить совместимость
              например, когда изменения в классе сделают отличным по смыслу: private static final long serialVersionUID = 1L;
              при явном изменении может привести к InvalidClassException при десериализации старых версий

//
Проблема сериализации Singleton
    Singleton - класс имеет только один экземпляр во всем приложении и дает глобальную точку доступа
                (конфигурация приложения, логирования, кэгирование, управление ресурсами)

    Проблема: после десериализации мы получим новый объект (создает Singleton еще раз)
    Решение: использовать метод readResolve(), который позволет заменить объект после дисериализации
             на уже существующий экземпляр Singleton

//
Клонирование объектов
1. Использование интерфейсла Cloneable()
    * Поверхностное клонирование: копирование объекта с примитивными полями и ссылками
    * Необходимо переопределение clone() как public (вместо protected) для использования
    * clone() возвращает копию объекта с клонированными примитивными полями.
    * Поля-ссылки в оригинале и клоне указывают на одни и те же объекты.

2. С использованием конструктора копирования объекта
    * В классе описывается конструктор,
    * Он принимает объект этого же класса в качестве параметров
    * Он копирует его (инициализирует значениями его полей новый объект)

3. С использованием сериализации
    * Сохраняем объект в поток байт с последущем восстановлением
    * Реализуем интерфейс Serializable

4. С использованием паттерна Прототип
    * можно реализовать всеми верхними способами, просто подход, не реализация
    * Создание копий объектов без знания деталей их конкретных классов
    * Используется, когда клонирование через конструктор сложное или неэффективное

//
Поверхностное клонирование (используется по умолчанию):
    * Копирует только верхний уровень объекта, не копируя вложенные объекты
    * Клонируются только ссылки на объекты, а не сами объекты
    * Изменения во вложенных объектах отразятся на оригинале, и наоборот
Глубокое копирование:
    * Рекурсивно копирует все данные объекта, включая вложенные и ссылочные объекты
    * Результатом являются два независимых объекта (например, коллекции, элементы дублируются из оригинальной коллекции)
    * Не изменяют оригинал

1. Глубокое клонирование требует следования определенным правилам:
   * Клонирование примитивных данных отдельно.
   * Поддержка клонирования для каждого члена класса, вызов super.clone() при переопределении метода clone().

2. Если член класса не поддерживает клонирование, необходимо создать новый экземпляр и скопировать атрибуты.

3. Способы глубокого клонирования:
   - Сериализация: объект должен поддерживать интерфейс Serializable.
                   Процесс включает сохранение объекта в массив байт и последующее чтение из него.
   - Использование библиотеки DeepCloneable:
        // Cloner cloner = new Cloner();
        // DeepCloneable clone = cloner.deepClone(this);

//
Лучше использовать конструктор копирования:
    * нет ошибок наследования
    * поля для клонирования указываются явно
    * возможность клонировать final поля

 */


/*
Как собрать путь
Относительный и абсолютный путь
Канонические пути
.exists, .isFile, .isDirectory, .length, .lastModified
Интерфейс path
ProcessBuilder
















 */