package L1_JavaCore1.a_JavaCore;

import java.util.Objects;

public class EqualsHashOverride {
    // ==================================== Переопределение equals() & hashCode() =================================== \\

    // hashCode: должен возвращать одинаковое значение для одного и того же объекта в течение одного запуска программы,
    //           может возвращать одинаковое значение для разных объектов.
    // equals:   должен быть рефлексивным, симметричным, транзитивным, консистентным и возвращать false для null.

    // equals изначально проверяет равенство ссылок (==), поэтому для корректного сравнения необходимо переопределить:
    //     1. Рефлексивность (объект равен самому себе, this == O)
    //     2. Неравенство с null (O != null)
    //     3. Симмеричность (a = b, то и b = a, равенство классов)
    //     4. Транзитивность (a = b, a = c, то и b = c)
    //     5. Постоянство (результаты меняются только при изменении ввода)
    Integer integer = 200;
    String string = "String";

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Types types = (Types) o;
        return integer == types.integer && Objects.equals(string, types.string);
    }

    // hashCode - это "прикидка": объекты возможно равны? Если да, вызываем equals для точного сравнения
    // Если переопределить только один метод, то нарушится контракт и возможна некорректная работа (HashMap, например)
    //
    // Коллизия - ситуация, когда два разных объекта или значения имеют один и тот же хэш-код.
    // решение: использовать цепочку, где каждая ячейка хэш-таблицы содержит не один объект,
    // а список (цепочку) объектов, имеющих одинаковый хэш-код
    @Override
    public int hashCode() {
        return Objects.hash(integer, string);
    }
}
