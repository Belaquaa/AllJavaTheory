package L3_GarbageCollector;

public class GarbageCollectorTheory {
    // =============================================== Сборщик мусора =============================================== \\

    // GC используется для автоматического управления памятью:
    // если нельзя дотянуться до объекта из стека - объект удаляется
    //
    // Можно явно вызвать. Не гарантируют немедленного выполнения сборки мусора
    public static void main(String[] args) {
        Runtime.getRuntime().gc();
        // или
        System.gc();
    }
    // Два способа определения:
    //   - Учет ссылок: если объект не имеет ссылок, он считается мусором (невозможно выявить циклические ссылки)
    //   - Трассировка: если до объекта нельязя дотянуться из корневых точек, он считается мусором
    //                  (объекты статических полей/из стека потоков/из JNI - JavaNativeInterface)

    // ============================================ Подходы сборки мусора =========================================== \\

    // Stop-the-world - остановка приложения [app->app->app->gc]
    //  + проще определить достижимость объектов (граф заморожен), проще перемещать объекты в куче
    //  - приложение останавливается, зависит от объема кучи
    //
    // Инкриментальная сборка [(gc+app)->(gc+app)->(gc+app)]
    //  + уменьшает паузы (много коротких пауз, фоновая сборка)
    //  - требуется синхронизировать работу с приложениемм, занимает больше времени

    // =================================================== Виды GC ================================================== \\

    // 1. Serial
    //  * работает в однопотоке, останавливает всё приложение для сборки мусора
    //  + прост в использовании
    //  - паузы в работе приложения, не подходит для многопоточных приложений и серверов
    //
    // 2. Parallel
    //  * использует несколько потоков, работает параллельно с приложением, останавливает всё приложение, производителен
    //  + производителен на многопроцессорных системах
    //  - приводит к более длительным паузам в сравнении с Serial
    //
    // 3. Concurrent Mark Sweep (CMS)
    //  * минимизирует паузы,  работает параллельно с приложением
    //  + небольшие паузы
    //  - потребляет больше ресурсов процессора, сложен в настройке
    //
    // 4. Garbage-First (G1) - самый популярный
    //  * разделяет кучу на регионы и собирает мусор сначала в тех, где это наиболее эффективно
    //  + короткие предсказуемые паузы, высокая производительность в больших системах, многопоточен
    //  + инкриментальная сборка: может ограничивать количество работы в паузе, чтобы удерживать ее в заданном пределе
    //  - может быть менее эффективен на маленьких объемах данных или в приложениях с меньшими требованиями к паузам
    //
    // Этапы G1:
    //  1) Minor GC
    //     - размещаются новые объекты в молодом поколении
    //     - место заполняется -> удаляются неиспользуемые
    //     - используемые перемещаются в пространство выживших
    //     - если выживщие долго используются, то перемещаются с старое поколение
    //  2) Major GC
    //     - долго проверяет все объекты в старом поколении, STW
    //     - живые объекты перемещает в начало (уплотняет), мусор остается в конце
    //  3) Full GC
    //     - запускает сначала Minor, затем Major
    //
    // 5. ZGC
    //  * использует регионы памяти и колорированные указатели для уменьшения пауз, инкрементальная сборка
    //  + очень короткие паузы, масштабируется до больших объемов памяти
    //  - может использовать больше системных ресурсов
    //
    // 6. Shenandoah
    //  * работает параллельно с приложением, инкрементальная сборка
    //  + очень короткие паузы, на зависит от размера кучи
    //  - может использовать больше системных ресурсов (CPU), сложен в настройке и оптимизации
    //
    // 7. Epsilon GC - эксперементальный
    //  * не выполняет сборку мусора
    //  + приложения работают без пауз, может использоваться для тестирования
    //  - не предназначен для использования в проде или в приложениях

    // ====================================== Определение производительности GC ===================================== \\

    // Throughput (пропускная способность) - объем используемых вычислительных ресурсов
    // Latency (задержка) - на какое время прерывается работа
    // Footprint (след) - объем используемой памяти
    //
    // Оптимизируем 2 из 3 компонентов / изменеяем размер кучи
}
